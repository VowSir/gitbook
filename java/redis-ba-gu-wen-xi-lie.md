# Redis八股文系列

参考地址:[https://blog.csdn.net/weixin\_70730532/article/details/126568929](https://blog.csdn.net/weixin\_70730532/article/details/126568929)



## 1.什么是 redis？

redis: redis 即 Remote Dictionary Server，用中文翻译过来可以理解为远程数据服务或远程字典服务。其是使用 C 语言的编写的 key-value 存储系统。

### 1.1 redis 适合的场景

* 缓存：减轻 MySQL 的查询压力，提升系统性能；
* 排行榜：利用 Redis 的 SortSet（有序集合）实现；
* 计算器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
* 好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；
* 消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；
* Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登录；采用 redis 保存 Session 后，无论用户落在哪台机器上都能够获取到对应的 Session 信息。

### 1.2 redis 不适合的场景

数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。

## 1.3 redis 为什么这么快？

![](https://cdn.staticaly.com/gh/VowSir/image-hosting@master/20230323/image.3hty95v9g0w0.webp)

## 2. redis 有哪些数据类型？可以应用在什么场景？

redis 总共有八种数据结构，五种基本数据类型和三种特殊数据类型。

* 五种基本数据类型
* string : 字符串类型，常被用来存储计数器，粉丝数等，简单的分布式锁也会用到该类型。
* hashmap : key - value 形式的，value 是一个map。
* list : 基本的数据类型，列表。在 Redis 中可以把 list 用作栈、队列、阻塞队列。
* set : 集合，不能有重复元素，可以做点赞，收藏等。
* zset : 有序集合，不能有重复元素，有序集合中的每个元素都需要指定一个分数，根据分数对元素进行升序排序。可以做排行榜。

三种特殊数据类型

* geospatial : Redis 在 3.2 推出 Geo 类型，该功能可以推算出地理位置信息，两地之间的距离。
* hyperloglog : 基数：数学上集合的元素个数，是不能重复的。这个数据结构常用于统计网站的 UV。
* bitmap : bitmap 就是通过最小的单位 bit 来进行0或者1的设置，表示某个元素对应的值或者状态。一个 bit 的值，或者是0，或者是1；也就是说一个 bit 能存储的最多信息是2。bitmap 常用于统计用户信息比如活跃粉丝和不活跃粉丝、登录和未登录、是否打卡等。

## 3.redis 是单线程还是多线程呢？&#x20;

* Redis 在 4.0 的时候引入了多线程来做大缓存的清除处理工作，主要是体现在大数据的异步删除功能上，例如 unlink key、flushdb async、flushall async 等，先清除 key ，接着异步清除对应的 value。&#x20;
* 在 Redis 6.0 之前的网络模型都是标准的单线程 reactor 模型。在 6.0 开始引入了一个非标准的多线程 reactor 模型，sub-reactor 此时会使用 socket 读取 client 请求，并处理命令的解析，然后具体写还是在主线程上执行。

### 3.1 redis 使用了多线程不会有线程安全的问题吗？为什么redis 6.0 之后改多线程呢？

不会，其实 redis 还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程，所以是不会有线程安全的问题。

之所以加入了多线程因为 redis 的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。

## 4. redis 的持久化机制有哪些？

redis 有两种持久化的方式，AOF 和 RDB。

AOF: AOF（append only file） 持久化，redis 每次执行一个命令时，都会把这个「命令原本的语句记录到一个.aod的文件当中，然后通过fsync策略，将命令执行后的数据持久化到磁盘中」(不包括读命令)。

* AOF 的优点:&#x20;

AOF可以「更好地保护数据不丢失」，一般AOF会以每隔1秒，通过后台的一个线程去执行一次fsync操作，如果redis进程挂掉，最多丢失1秒的数据。

AOF是将命令直接追加在文件末尾的,「写入性能非常高」。

AOF日志文件的命令通过非常可读的方式进行记录，这个非常「适合做灾难性的误删除紧急恢复」，如果某人不小心用 flushall 命令清空了所有数据，只要这个时候还没有执行 rewrite，那么就可以将日志文件中的 flushall 删除，进行恢复。

* AOF 的缺点:&#x20;

对于同一份数据源来说,一般情况下AOF 文件比 RDB 数据快照要大。

由于 .aof 的每次命令都会写入，那么相对于 RDB 来说「需要消耗的性能也就更多」，当然也会有 aof 重写将 aof 文件优化。

「数据恢复比较慢」，不适合做冷备。

RDB: 把某个时间点 redis 内存中的数据以二进制的形式存储的一个.rdb为后缀的文件当中，也就是「周期性的备份redis中的整个数据」，这是redis默认的持久化方式，也就是我们说的快照(snapshot)，是采用 fork 子进程的方式来写时同步的。

* RDB 的优点:&#x20;

它是将某一时间点redis内的所有数据保存下来，所以当我们做「大型的数据恢复时，RDB的恢复速度会很快」。

由于RDB的FROK子进程这种机制，对于给客户端提供读写服务的影响会非常小。

* RDB 的缺点:&#x20;
* 举个例子假设我们定时5分钟备份一次，在10:00的时候 redis 备份了数据，但是如果在10:04的时候服务挂了，那么我们就会丢失在10:00到10:04的整个数据。

「有可能会产生长时间的数据丢失」。

可能会有长时间停顿:我们前面讲了，fork 子进程这个过程是和 redis 的数据量有很大关系的，如果「数据量很大，那么很有可能会使redis暂停几秒」。
